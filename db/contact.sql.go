// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: contact.sql

package db

import (
	"context"
)

const deleteContact = `-- name: DeleteContact :exec
DELETE FROM
    contact
WHERE
    id = ?
`

func (q *Queries) DeleteContact(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteContact, id)
	return err
}

const getContactIdByNames = `-- name: GetContactIdByNames :one
SELECT
    contact.id
FROM
    contact
    INNER JOIN company ON company.id = contact.company_id
WHERE
    contact.fist_name = ?
    AND contact.last_name = ?
    AND company.name = ?
LIMIT
    1
`

type GetContactIdByNamesParams struct {
	FistName string `json:"fist_name"`
	LastName string `json:"last_name"`
	Name     string `json:"name"`
}

func (q *Queries) GetContactIdByNames(ctx context.Context, arg GetContactIdByNamesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getContactIdByNames, arg.FistName, arg.LastName, arg.Name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertContact = `-- name: InsertContact :one
INSERT INTO
    contact (
        company_id,
        job_position,
        fist_name,
        last_name,
        email,
        phone_number,
        notes
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?) RETURNING id, company_id, job_position, fist_name, last_name, email, phone_number, notes
`

type InsertContactParams struct {
	CompanyID   int64  `json:"company_id"`
	JobPosition string `json:"job_position"`
	FistName    string `json:"fist_name"`
	LastName    string `json:"last_name"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
	Notes       string `json:"notes"`
}

func (q *Queries) InsertContact(ctx context.Context, arg InsertContactParams) (Contact, error) {
	row := q.db.QueryRowContext(ctx, insertContact,
		arg.CompanyID,
		arg.JobPosition,
		arg.FistName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.Notes,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.JobPosition,
		&i.FistName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.Notes,
	)
	return i, err
}

const listContact = `-- name: ListContact :many
SELECT
    contact.id, contact.company_id, contact.job_position, contact.fist_name, contact.last_name, contact.email, contact.phone_number, contact.notes,
    company.name AS company_name,
    (
        SELECT
            cast(
                CASE
                    WHEN max(event.date) IS NULL THEN 0
                    ELSE max(event.date)
                END AS integer
            )
        FROM
            event
            INNER JOIN event_contacts ON event_contacts.event_id = event.id
        WHERE
            event_contacts.contact_id = contact.id
            AND event.date <= unixepoch()
    ) AS last_event,
    (
        SELECT
            cast(
                CASE
                    WHEN min(event.date) IS NULL THEN 0
                    ELSE min(event.date)
                END AS integer
            )
        FROM
            event
            INNER JOIN event_contacts ON event_contacts.event_id = event.id
        WHERE
            event_contacts.contact_id = contact.id
            AND event.date >= unixepoch()
    ) AS next_event
FROM
    contact
    INNER JOIN company ON company.id = contact.company_id
`

type ListContactRow struct {
	ID          int64  `json:"id"`
	CompanyID   int64  `json:"company_id"`
	JobPosition string `json:"job_position"`
	FistName    string `json:"fist_name"`
	LastName    string `json:"last_name"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
	Notes       string `json:"notes"`
	CompanyName string `json:"company_name"`
	LastEvent   int64  `json:"last_event"`
	NextEvent   int64  `json:"next_event"`
}

func (q *Queries) ListContact(ctx context.Context) ([]ListContactRow, error) {
	rows, err := q.db.QueryContext(ctx, listContact)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactRow{}
	for rows.Next() {
		var i ListContactRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.JobPosition,
			&i.FistName,
			&i.LastName,
			&i.Email,
			&i.PhoneNumber,
			&i.Notes,
			&i.CompanyName,
			&i.LastEvent,
			&i.NextEvent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContact = `-- name: UpdateContact :exec
UPDATE
    contact
SET
    company_id = ?,
    job_position = ?,
    fist_name = ?,
    last_name = ?,
    email = ?,
    phone_number = ?,
    notes = ?
WHERE
    id = ?
`

type UpdateContactParams struct {
	CompanyID   int64  `json:"company_id"`
	JobPosition string `json:"job_position"`
	FistName    string `json:"fist_name"`
	LastName    string `json:"last_name"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phone_number"`
	Notes       string `json:"notes"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) error {
	_, err := q.db.ExecContext(ctx, updateContact,
		arg.CompanyID,
		arg.JobPosition,
		arg.FistName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.Notes,
		arg.ID,
	)
	return err
}
